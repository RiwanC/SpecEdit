package Paster.plugin;

/*Generated by MPS */

import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.project.Project;
import org.jetbrains.mps.openapi.model.SModel;
import java.awt.datatransfer.Transferable;
import com.intellij.ide.CopyPasteManagerEx;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import org.jetbrains.mps.openapi.module.SModule;
import parser.TLAPlusGrammarLexer;
import org.antlr.v4.runtime.ANTLRInputStream;
import java.io.StringReader;
import parser.TLAPlusGrammarParser;
import org.antlr.v4.runtime.CommonTokenStream;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import java.util.List;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import org.antlr.v4.runtime.RecognitionException;
import jetbrains.mps.ide.datatransfer.SModelDataFlavor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SContainmentLink;
import org.jetbrains.mps.openapi.language.SProperty;

public class AntlrPaster {

  public AntlrPaster() {
  }
  public void pasteRules(SNode anchor, IOperationContext operationContext, Project project) {
    String clipboardText = getStringFromClipboard();
    if (clipboardText == null) {
      return;
    }
    if (clipboardText.contains("----")) {
      pasteGrammarAsNodes(anchor, anchor.getModel(), clipboardText, operationContext, project);
    } else {
      // do nothing 
    }
  }
  public void pasteJavaAsClass(SModel model, IOperationContext operationContext, Project project) {
    String javaCode = getStringFromClipboard();
    if (javaCode == null) {
      return;
    }
    pasteGrammarAsNodes(null, model, javaCode, operationContext, project);
  }
  public String getStringFromClipboard() {
    Transferable contents = null;
    for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
      if (trf != null && trf.isDataFlavorSupported(DataFlavor.stringFlavor)) {
        contents = trf;
      }
      break;
    }
    if (contents == null) {
      return null;
    }
    if (contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      try {
        Object data = contents.getTransferData(DataFlavor.stringFlavor);
        if (data instanceof String) {
          return (String) data;
        }
      } catch (UnsupportedFlavorException ex) {
        return null;
      } catch (IOException ex) {
      }
    }
    return null;
  }
  public void pasteGrammarAsNodes(SNode anchor, SModel model, final String TextFromClipboard, IOperationContext operationContext, Project project) {
    SModule module = model.getModule();
    try {
      TLAPlusGrammarLexer lexer = new TLAPlusGrammarLexer(new ANTLRInputStream(new StringReader(TextFromClipboard)));
      TLAPlusGrammarParser parser = new TLAPlusGrammarParser(new CommonTokenStream(lexer));
      TLAPlusGrammarParser.ModuleContext moduleContext = parser.module();
      // use the following to print types of nodes on the parse tree: 
      saveTreeAsPostScript(moduleContext, parser);
      // initiate walk of tree with listener 
      SNode moduleNode = SNodeOperations.getNodeAncestor(anchor, CONCEPTS.Module$3n, true, false);
      AntlrUnitVisitor visitor = new AntlrUnitVisitor();
      SNode parsedGrammar = ((SNode) visitor.visitModule(moduleContext));
      List<SNode> UnitList = SLinkOperations.getChildren(parsedGrammar, LINKS.SetOfUnits$fqCa);
      ListSequence.fromList(SLinkOperations.getChildren(moduleNode, LINKS.SetOfUnits$fqCa)).addSequence(ListSequence.fromList(UnitList));
      SPropertyOperations.assign(moduleNode, PROPS.ModuleName$iAUB, SPropertyOperations.getString(parsedGrammar, PROPS.ModuleName$iAUB));
      ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(moduleNode, LINKS.SetOfModuleNames$Bn0), LINKS.ListM$Vevw)).addSequence(ListSequence.fromList(SLinkOperations.getChildren(SLinkOperations.getTarget(parsedGrammar, LINKS.SetOfModuleNames$Bn0), LINKS.ListM$Vevw)));
    } catch (IOException ioException) {
    } catch (RecognitionException e) {
    }
  }

  private void saveTreeAsPostScript(TLAPlusGrammarParser.ModuleContext tree, TLAPlusGrammarParser parser) throws IOException {
    // none 
  }
  public static boolean areDataAvailableInClipboard() {
    Transferable trf = CopyPasteManagerEx.getInstanceEx().getContents();
    if (trf == null || trf.isDataFlavorSupported(SModelDataFlavor.sNode)) {
      return false;
    }
    if (trf.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      return true;
    }
    return false;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Module$3n = MetaAdapterFactory.getConcept(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x66c514aade18245bL, "TLA.structure.Module");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink SetOfUnits$fqCa = MetaAdapterFactory.getContainmentLink(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x66c514aade18245bL, 0x66c514aade1936a2L, "SetOfUnits");
    /*package*/ static final SContainmentLink SetOfModuleNames$Bn0 = MetaAdapterFactory.getContainmentLink(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x66c514aade18245bL, 0x66c514aade19ce7bL, "SetOfModuleNames");
    /*package*/ static final SContainmentLink ListM$Vevw = MetaAdapterFactory.getContainmentLink(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x3f9c65b68f3e2c45L, 0x3f9c65b68f3e2c46L, "ListM");
  }

  private static final class PROPS {
    /*package*/ static final SProperty ModuleName$iAUB = MetaAdapterFactory.getProperty(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x66c514aade18245bL, 0x66c514aade19a4b0L, "ModuleName");
  }
}
