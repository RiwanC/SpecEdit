package Paster.plugin;

/*Generated by MPS */

import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.smodel.IOperationContext;
import jetbrains.mps.project.Project;
import org.apache.log4j.Priority;
import org.jetbrains.mps.openapi.model.SModel;
import java.awt.datatransfer.Transferable;
import com.intellij.ide.CopyPasteManagerEx;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.UnsupportedFlavorException;
import java.io.IOException;
import org.jetbrains.mps.openapi.module.SModule;
import parser.TLAPlusGrammarLexer;
import org.antlr.v4.runtime.ANTLRInputStream;
import java.io.StringReader;
import parser.TLAPlusGrammarParser;
import org.antlr.v4.runtime.CommonTokenStream;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SNodeOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPropertyOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SLinkOperations;
import org.antlr.v4.runtime.RecognitionException;
import jetbrains.mps.ide.datatransfer.SModelDataFlavor;
import org.jetbrains.mps.openapi.language.SConcept;
import jetbrains.mps.smodel.adapter.structure.MetaAdapterFactory;
import org.jetbrains.mps.openapi.language.SProperty;
import org.jetbrains.mps.openapi.language.SContainmentLink;

public class AntlrPaster {
  private static Logger LOG = LogManager.getLogger(AntlrPaster.class);
  public AntlrPaster() {
  }
  public void pasteRules(SNode anchor, IOperationContext operationContext, Project project) {
    String clipboardText = getStringFromClipboard();
    if (clipboardText == null) {
      return;
    }
    if (clipboardText.contains("----")) {
      LOG.log(Priority.INFO, "valid");
      pasteGrammarAsNodes(anchor, anchor.getModel(), clipboardText, operationContext, project);
    } else {
      pasteRulesAsNodes(anchor, anchor.getModel(), clipboardText, operationContext, project);
    }
  }
  public void pasteJavaAsClass(SModel model, IOperationContext operationContext, Project project) {
    String javaCode = getStringFromClipboard();
    if (javaCode == null) {
      return;
    }
    pasteGrammarAsNodes(null, model, javaCode, operationContext, project);
  }
  public String getStringFromClipboard() {
    Transferable contents = null;
    for (Transferable trf : CopyPasteManagerEx.getInstanceEx().getAllContents()) {
      if (trf != null && trf.isDataFlavorSupported(DataFlavor.stringFlavor)) {
        contents = trf;
      }
      break;
    }
    if (contents == null) {
      return null;
    }
    if (contents.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      try {
        Object data = contents.getTransferData(DataFlavor.stringFlavor);
        if (data instanceof String) {
          return (String) data;
        }
      } catch (UnsupportedFlavorException ex) {
        return null;
      } catch (IOException ex) {
        AntlrPaster.LOG.error(null, ex);
      }
    }
    return null;
  }
  public void pasteGrammarAsNodes(SNode anchor, SModel model, final String antlrRulesAsText, IOperationContext operationContext, Project project) {
    SModule module = model.getModule();
    try {
      TLAPlusGrammarLexer lexer = new TLAPlusGrammarLexer(new ANTLRInputStream(new StringReader(antlrRulesAsText)));
      TLAPlusGrammarParser parser = new TLAPlusGrammarParser(new CommonTokenStream(lexer));
      TLAPlusGrammarParser.ModuleContext tree = parser.module();
      // use the following to print types of nodes on the parse tree: 
      saveTreeAsPostScript(tree, parser);

      // initiate walk of tree with listener 
      SNode moduleNode = SNodeOperations.getNodeAncestor(anchor, CONCEPTS.Module$3n, true, false);
      SPropertyOperations.assign(moduleNode, PROPS.ModuleName$iAUB, "jesuislaehoh");
      SLinkOperations.addNewChild(moduleNode, LINKS.SetOfUnits$fqCa, CONCEPTS.Separator$Hy);
    } catch (IOException ioException) {
    } catch (RecognitionException e) {
    }
  }

  public void pasteRulesAsNodes(SNode anchor, SModel model, final String antlrRulesAsText, IOperationContext operationContext, Project project) {
    SModule module = model.getModule();
    try {
      TLAPlusGrammarLexer lexer = new TLAPlusGrammarLexer(new ANTLRInputStream(new StringReader(antlrRulesAsText)));
      TLAPlusGrammarParser parser = new TLAPlusGrammarParser(new CommonTokenStream(lexer));
      TLAPlusGrammarParser.UnitContext tree = parser.unit();
      // use the following to print types of nodes on the parse tree: 

      // initiate walk of tree with listener 
      SNode moduleNode = SNodeOperations.getNodeAncestor(anchor, CONCEPTS.Module$3n, true, false);
    } catch (IOException ioexception) {
    } catch (RecognitionException e) {
    }
  }
  private void saveTreeAsPostScript(TLAPlusGrammarParser.ModuleContext tree, TLAPlusGrammarParser parser) throws IOException {
  }
  public static boolean areDataAvailableInClipboard() {
    Transferable trf = CopyPasteManagerEx.getInstanceEx().getContents();
    if (trf == null || trf.isDataFlavorSupported(SModelDataFlavor.sNode)) {
      return false;
    }
    if (trf.isDataFlavorSupported(DataFlavor.stringFlavor)) {
      return true;
    }
    return false;
  }

  private static final class CONCEPTS {
    /*package*/ static final SConcept Module$3n = MetaAdapterFactory.getConcept(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x66c514aade18245bL, "TLA.structure.Module");
    /*package*/ static final SConcept Separator$Hy = MetaAdapterFactory.getConcept(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x467903da84aac9a1L, "TLA.structure.Separator");
  }

  private static final class PROPS {
    /*package*/ static final SProperty ModuleName$iAUB = MetaAdapterFactory.getProperty(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x66c514aade18245bL, 0x66c514aade19a4b0L, "ModuleName");
  }

  private static final class LINKS {
    /*package*/ static final SContainmentLink SetOfUnits$fqCa = MetaAdapterFactory.getContainmentLink(0x7a6b8f83d2024e59L, 0x94ecf562edfca98dL, 0x66c514aade18245bL, 0x66c514aade1936a2L, "SetOfUnits");
  }
}
